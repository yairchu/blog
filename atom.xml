<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title></title>
    <link href="https://yairchu.github.io//atom.xml" rel="self" type="application/rss+xml" />
  <updated>2020-04-24T07:51:SZ</updated>
  <author>
      <name></name>
  </author>
  <id>https://yairchu.github.io//</id>

  <entry>
      <title>Break big merges to smaller pieces</title>
      <link href="https://yairchu.github.io/posts/split-merge-to-smaller-pieces"/>
      <id>https://yairchu.github.io/posts/split-merge-to-smaller-pieces</id>
      <updated>2020-04-22T00:00:SZ</updated>
      <category term="code"/>
      <category term="git"/>
      <category term="merge"/>
      <category term="rebase"/>
      <summary>Tactics for merging in smaller chunks</summary>
      <content type="html"><![CDATA[<p>Merges with many conflicts are horrifying.</p>
<p>As the chance for a conflict resolution mistake increases, we can't run the tests to verify correctness until all of the conflicts are resolved.</p>
<p>Often, however, we can break the merge process down to smaller pieces, where we can check and save our work after each step!</p>
<p><img src="/images/merge.svg" alt="Git merge" /></p>
<p>The simplest way to break a merge down is to apply "sub-merges" which merge a single commit at a time.</p>
<p><img src="/images/sub-merge.svg" alt="Git merge with sub-merges" /></p>
<p>Each sub-merge involves less conflicts and we can run our test-suite to verify ourselves.</p>
<p>A down-side of this simple approach is that it may be tedious to do manually and it will result in a very complicated git history tree.</p>
<p>One way to resolve the history issue is to rewrite it, which one can do with <code>git rebase</code>.</p>
<p>If we rebase rather than merge, the following script makes the process easy by automating it:</p>
<h2 id="sub-rebasesh">sub-rebase.sh</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="va">BASE=${1:-</span>master<span class="va">}</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">while</span> <span class="fu">true</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">do</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="va">NEXT_COMMIT=$(</span><span class="fu">git</span> rev-list ..<span class="va">$BASE</span> <span class="kw">|</span> <span class="fu">tail</span> -n 1<span class="va">)</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    [<span class="st">&quot;</span><span class="va">$NEXT_COMMIT</span><span class="st">&quot;</span> == <span class="st">&quot;&quot;</span>] <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;Done&quot;</span> <span class="kw">&amp;&amp;</span> <span class="bu">exit</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="fu">git</span> rebase <span class="va">$NEXT_COMMIT</span> <span class="kw">||</span> <span class="bu">exit</span> 1</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">done</span></span></code></pre></div>
<p>It rebases up to the first parent of the base branch which has any merge conflicts to address (so it doesn't accumulate conflicts from multiple commits).</p>
<p>Apply it to advance towards your complete merge in smaller, testable pieces.</p>
<p>Notes:</p>
<ul>
<li>This process works well when we commit often in small commits.</li>
<li>For resolving the conflicts, <a href="/posts/git-mediate-stops-fear">I recommend using git-mediate</a></li>
<li>Image from <a href="https://www.reddit.com/r/funny/comments/ub7x3/fail_shape_sorter_college_campus_level/">this meme</a></li>
</ul>]]></content>
  </entry>
  <entry>
      <title>Basic error reporting for optics</title>
      <link href="https://yairchu.github.io/posts/optics-with-error-reporting"/>
      <id>https://yairchu.github.io/posts/optics-with-error-reporting</id>
      <updated>2020-01-02T00:00:SZ</updated>
      <category term="code"/>
      <category term="haskell"/>
      <category term="optics"/>
      <summary>Adding error reportinh to folds, traversals and prisms</summary>
      <content type="html"><![CDATA[<p>When <a href="http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Fold.html#v:-94--63-"><code>^?</code></a> returns <code>Nothing</code>, it is often desired to know why.</p>
<p>Let's define a <code>^??</code> operator which returns an <code>Either</code> instead of a <code>Maybe</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">newtype</span> <span class="dt">ConstEither</span> e r a <span class="ot">=</span> <span class="dt">ConstEither</span> {<span class="ot"> getConstEither ::</span> <span class="dt">Either</span> e r }</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">infixl</span> <span class="dv">8</span> <span class="op">^??</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">(^??) ::</span> s <span class="ot">-&gt;</span> <span class="dt">LensLike&#39;</span> (<span class="dt">ConstEither</span> e a) s a <span class="ot">-&gt;</span> <span class="dt">Either</span> e a</span>
<span id="cb1-6"><a href="#cb1-6"></a>whole <span class="op">^??</span> f <span class="ot">=</span> f (<span class="dt">ConstEither</span> <span class="op">.</span> <span class="dt">Right</span>) whole <span class="op">&amp;</span> getConstEither</span></code></pre></div>
<p>The standard optics (<code>Traversal</code>, <code>Prism</code>, etc) do not work with our new combinator, so let's see how we can define ones which would.</p>
<p><a href="http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Traversal.html#v:Traversal"><code>Traversal s t a b</code></a> is <code>forall f. Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t</code> and it uses <code>f</code>'s <code>pure</code> in the empty case, so we'll replace the <code>Applicative</code> with a verbose variant which supplies error information in the empty case:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">class</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">VerboseApplicative</span> e f <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">    vpure ::</span> e <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">type</span> <span class="dt">VerboseTraversal</span> e s t a b <span class="ot">=</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="kw">forall</span> f<span class="op">.</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="dt">VerboseApplicative</span> e f <span class="ot">=&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="dt">LensLike</span> f s t a b</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">type</span> <span class="dt">VerbosePrism</span> e s t a b <span class="ot">=</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="kw">forall</span> p f<span class="op">.</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    (<span class="dt">Choice</span> p, <span class="dt">VerboseApplicative</span> e f) <span class="ot">=&gt;</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="dt">Optic</span> p f s t a b</span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="kw">type</span> <span class="dt">VerboseTraversal&#39;</span> e s a <span class="ot">=</span> <span class="dt">VerboseTraversal</span> e s s a a</span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="kw">type</span> <span class="dt">VerbosePrism&#39;</span> e s a <span class="ot">=</span> <span class="dt">VerbosePrism</span> e s s a a</span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="co">-- Verbose optics support for (^.) and (^..)</span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="kw">instance</span> <span class="dt">Monoid</span> r <span class="ot">=&gt;</span> <span class="dt">VerboseApplicative</span> e (<span class="dt">Const</span> r) <span class="kw">where</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>    vpure _ <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb2-20"><a href="#cb2-20"></a></span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="co">-- Verbose optics support for `preview`, aka (#)</span></span>
<span id="cb2-22"><a href="#cb2-22"></a><span class="kw">instance</span> <span class="dt">VerboseApplicative</span> e <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb2-23"><a href="#cb2-23"></a>    vpure _ <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb2-24"><a href="#cb2-24"></a></span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="co">-- Verbose optics support for our (^??)</span></span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">ConstEither</span> e r) <span class="kw">where</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>    <span class="dt">ConstEither</span> x <span class="op">&lt;.&gt;</span> _ <span class="ot">=</span> <span class="dt">ConstEither</span> x</span>
<span id="cb2-28"><a href="#cb2-28"></a><span class="kw">instance</span> e <span class="op">~</span> e&#39; <span class="ot">=&gt;</span> <span class="dt">VerboseApplicative</span> e (<span class="dt">ConstEither</span> e&#39; r) <span class="kw">where</span></span>
<span id="cb2-29"><a href="#cb2-29"></a>    vpure e _ <span class="ot">=</span> <span class="dt">ConstEither</span> (<span class="dt">Left</span> e)</span></code></pre></div>
<p>Now we may want an operator to transform optics into verbose optics:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- Given an error message constructor, turns:</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">-- * Traversal to VerboseTraversal</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">-- * Prism to VerbosePrism</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">verbose ::</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    (<span class="dt">Profunctor</span> p, <span class="dt">VerboseApplicative</span> e f) <span class="ot">=&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    (t <span class="ot">-&gt;</span> e) <span class="ot">-&gt;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="dt">Optic</span> p (<span class="dt">Lift</span> f) s t a b <span class="ot">-&gt;</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="dt">Optic</span> p f s t a b</span>
<span id="cb3-9"><a href="#cb3-9"></a>verbose e t <span class="ot">=</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>    rmap f <span class="op">.</span> t <span class="op">.</span> rmap <span class="dt">Other</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="kw">where</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>        f (<span class="dt">Other</span> r) <span class="ot">=</span> r</span>
<span id="cb3-13"><a href="#cb3-13"></a>        f (<span class="dt">Pure</span> r) <span class="ot">=</span> vpure (e r) r</span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">-- A fixed variant of transformers:Control.Applicative.Lift -</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">-- Turns an Apply to an Applicative</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">-- (transformer&#39;s versions Applicative instance requires Applicative f)</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="kw">data</span> <span class="dt">Lift</span> f a <span class="ot">=</span> <span class="dt">Pure</span> a <span class="op">|</span> <span class="dt">Other</span> (f a)</span>
<span id="cb3-19"><a href="#cb3-19"></a>    <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="kw">instance</span> <span class="dt">Apply</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Lift</span> f) <span class="kw">where</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Pure</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>    <span class="dt">Pure</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Pure</span> x <span class="ot">=</span> <span class="dt">Pure</span> (f x)</span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="dt">Pure</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Other</span> x <span class="ot">=</span> <span class="dt">Other</span> (f <span class="op">&lt;$&gt;</span> x)</span>
<span id="cb3-25"><a href="#cb3-25"></a>    <span class="dt">Other</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Pure</span> x <span class="ot">=</span> <span class="dt">Other</span> (f <span class="op">&lt;&amp;&gt;</span> (<span class="op">$</span> x))</span>
<span id="cb3-26"><a href="#cb3-26"></a>    <span class="dt">Other</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Other</span> x <span class="ot">=</span> <span class="dt">Other</span> (liftF2 (<span class="op">$</span>) f x)</span></code></pre></div>
<p>Note that I haven't found how to make <code>verbose</code> also turn a <a href="http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Fold.html#t:Fold"><code>Fold</code></a> to a verbose variant.</p>
<p>To see our verbose optics in action we'll make some verbose variants of optics from <a href="https://hackage.haskell.org/package/lens-aeson/docs/Data-Aeson-Lens.html"><code>lens-aeson</code></a>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> <span class="dt">Err</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="ot">v_Value ::</span> (<span class="dt">AsValue</span> t, <span class="dt">Show</span> t) <span class="ot">=&gt;</span> <span class="dt">VerbosePrism&#39;</span> <span class="dt">Err</span> t <span class="dt">Value</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>v_Value <span class="ot">=</span> verbose (\x <span class="ot">-&gt;</span> <span class="st">&quot;Doesn&#39;t parse as JSON: &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> x) _Value</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="ot">v_Double ::</span> (<span class="dt">ToJSON</span> t, <span class="dt">AsNumber</span> t) <span class="ot">=&gt;</span> <span class="dt">VerbosePrism&#39;</span> <span class="dt">Err</span> t <span class="dt">Double</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>v_Double <span class="ot">=</span> verbose (expectJson <span class="st">&quot;number&quot;</span>) _Double</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="ot">vnth ::</span> (<span class="dt">ToJSON</span> t, <span class="dt">AsValue</span> t) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">VerboseTraversal&#39;</span> <span class="dt">Err</span> t <span class="dt">Value</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>vnth i <span class="ot">=</span> verbose (expectJson (<span class="st">&quot;item at index &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> i)) (nth i)</span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="ot">expectJson ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Err</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>expectJson e x <span class="ot">=</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="st">&quot;Expected &quot;</span> <span class="op">&lt;&gt;</span> e <span class="op">&lt;&gt;</span> <span class="st">&quot; but found &quot;</span> <span class="op">&lt;&gt;</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>    Data.ByteString.Lazy.Char8.unpack (encode x)</span></code></pre></div>
<p>Now let's see they work:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp"># Verbose traversals can work like regular traversals</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="op">&gt;</span> <span class="st">&quot;[1, \&quot;x\&quot;]&quot;</span> <span class="op">^?</span> _Value <span class="op">.</span> nth <span class="dv">0</span> <span class="op">.</span> _Double</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="dt">Just</span> <span class="fl">1.0</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="op">&gt;</span> <span class="st">&quot;[1, \&quot;x\&quot;]&quot;</span> <span class="op">^?</span> v_Value <span class="op">.</span> vnth <span class="dv">0</span> <span class="op">.</span> v_Double</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="dt">Just</span> <span class="fl">1.0</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="op">&gt;</span> <span class="st">&quot;[1, \&quot;x\&quot;]&quot;</span> <span class="op">^?</span> v_Value <span class="op">.</span> vnth <span class="dv">1</span> <span class="op">.</span> v_Double</span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="dt">Nothing</span></span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="pp"># But using ^?? rather than ^? we can also get error info</span></span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="op">&gt;</span> <span class="st">&quot;[1, \&quot;x\&quot;]&quot;</span> <span class="op">^??</span> v_Value <span class="op">.</span> vnth <span class="dv">0</span> <span class="op">.</span> v_Double</span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="dt">Right</span> <span class="fl">1.0</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="op">&gt;</span> <span class="st">&quot;[1, \&quot;x\&quot;]&quot;</span> <span class="op">^??</span> v_Value <span class="op">.</span> vnth <span class="dv">1</span> <span class="op">.</span> v_Double</span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="dt">Left</span> <span class="st">&quot;Expected number but found \&quot;x\&quot;&quot;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="op">&gt;</span> <span class="st">&quot;[1, \&quot;x\&quot;]&quot;</span> <span class="op">^??</span> v_Value <span class="op">.</span> vnth <span class="dv">2</span> <span class="op">.</span> v_Double</span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="dt">Left</span> <span class="st">&quot;Expected item at index 2 but found [1,\&quot;x\&quot;]&quot;</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="op">&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">^??</span> v_Value <span class="op">.</span> v_Double</span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="dt">Left</span> <span class="st">&quot;Doesn&#39;t parse as JSON: \&quot;hello\&quot;&quot;</span></span></code></pre></div>
<h2 id="notes">Notes</h2>
<p><a href="https://www.reddit.com/r/haskell/comments/eh4gpg/elegant_ast_parsing_and_building_with_prisms/fcl7dvv/">In the previous post's discussion</a>, <a href="https://github.com/ekmett/lens"><code>lens</code></a>'s creator Edward Kmett noted that in <code>lens</code>'s early days they experimented with a different formulation of error-reporting optics that placed the extra information in <code>Optic p f s t a b</code>'s <code>p</code> rather than <code>f</code>, but that with that formulation they ran into problems with inference and that this new formulation may work better.</p>
<h2 id="request-for-feedback">Request for feedback</h2>
<ul>
<li>Do you have use cases for this? If so, do you think that this should belong in <code>lens</code>?</li>
<li>Should it belong in a separate package? Perhaps along with the previous posts' <code>Prism</code> combinators and with additional optics like <a href="https://github.com/ekmett/lens/issues/904">inverted <code>Prism</code>s and partial <code>Iso</code>s</a>?</li>
<li>Any code suggestions or improvements?</li>
</ul>
<p>Discussion</p>
<ul>
<li><img src="/images/reddit.svg" alt="reddit" style="width: 20px; display: inline;"/> <a href="https://www.reddit.com/r/haskell/comments/ej15ar/basic_error_reporting_for_optics/">r/haskell</a></li>
</ul>
<p><a href="https://www.peakpx.com/637476/railway-line-train-railway-crossing-sky-no-people">Image source</a></p>]]></content>
  </entry>
  <entry>
      <title>Elegant AST Parsing and Building with Prisms</title>
      <link href="https://yairchu.github.io/posts/codecs-as-prisms-asts"/>
      <id>https://yairchu.github.io/posts/codecs-as-prisms-asts</id>
      <updated>2019-12-29T00:00:SZ</updated>
      <category term="code"/>
      <category term="declarative"/>
      <category term="haskell"/>
      <category term="optics"/>
      <category term="parsing"/>
      <category term="construct"/>
      <summary>Declarative parsing and pretty printing for language ASTs</summary>
      <content type="html"><![CDATA[<p>Following my <a href="codecs-as-prisms">previous post</a> which suggested the use of <code>Prism</code>s for parsing and building, using a binary format example - I also want to show how the same idea can work nicely for parsing and building programming language syntax.</p>
<h2 id="simple-ast-example">Simple AST example</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="ot">=</span> <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="op">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a>makePrisms &#39;<span class="dt">&#39;Expr</span></span></code></pre></div>
<p>Here's our <code>Prism</code> for parsing and building the above AST:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">&gt;</span> expr <span class="op">#</span> <span class="dt">Mul</span> (<span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">1</span>) (<span class="dt">Lit</span> <span class="dv">2</span>)) (<span class="dt">Lit</span> <span class="dv">3</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="st">&quot;(1 + 2) * 3&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ot">expr ::</span> <span class="dt">Prism&#39;</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>expr <span class="ot">=</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    tokens <span class="op">.</span>      <span class="co">-- convert string to tokens</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    takeExpr <span class="op">.</span>    <span class="co">-- take the expression</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    secondOnly [] <span class="co">-- and there should be no remaining tokens</span></span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ot">takeExpr ::</span> <span class="dt">Prism&#39;</span> [<span class="dt">String</span>] (<span class="dt">Expr</span>, [<span class="dt">String</span>])</span>
<span id="cb2-11"><a href="#cb2-11"></a>takeExpr <span class="ot">=</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    infixOpLeftRecursion <span class="st">&quot;+&quot;</span> _Add <span class="op">$</span> <span class="co">-- Additions of</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    infixOpLeftRecursion <span class="st">&quot;*&quot;</span> _Mul <span class="op">$</span> <span class="co">-- multiplications of</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>    tryMatch (asideFirst _Lit)      <span class="co">-- literals or</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>        (_Cons <span class="op">.</span> asideFirst _Show) <span class="op">$</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>    _Cons <span class="op">.</span> firstOnly <span class="st">&quot;(&quot;</span> <span class="op">.</span>         <span class="co">-- expressions in parentheses</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>        takeExpr <span class="op">.</span> aside (_Cons <span class="op">.</span> firstOnly <span class="st">&quot;)&quot;</span>)</span></code></pre></div>
<p>This uses the following combinators:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Cons.html"><code>_Cons</code></a>, <a href="http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Prism.html#v:_Show"><code>_Show</code></a>, and <a href="http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Prism.html#v:aside"><code>aside</code></a> from <a href="http://hackage.haskell.org/package/lens"><code>Control.Lens</code></a></li>
<li><code>firstOnly</code>, <code>secondOnly</code>, and <code>asideFirst</code> from <a href="codecs-as-prisms#parse-build-prism-combinators">the previous post</a></li>
<li><code>tokens</code>, <code>infixOpLeftRecursion</code>, and <code>tryMatch</code> are defined in the <a href="#appendix">appendix</a> at the bottom</li>
</ul>
<h2 id="observations">Observations</h2>
<p>In the previous post, <code>Prism</code>s didn't match up to Python's <a href="https://construct.readthedocs.io/en/latest/intro.html">Construct</a> in encoding binary protocols, where Construct made good use of structural duck types (though this appears solvable with some effort). However, for programming language syntax <code>Prism</code>s seem very elegant imho.</p>
<p>Note how we harness optics' parametricity and composition. In the previous post we parsed <code>ByteString</code>s but here we parse <code>String</code> and we start by converting them to tokens (ie <code>[String]</code>) and parse that.</p>
<h3 id="renegade-prisms">Renegade prisms</h3>
<p>Unlike the previous post's lawful <code>Prism</code>s, this post's parsing is lossy, so it breaks the <a href="https://artyom.me/lens-over-tea-2#traversal-laws"><code>Traversal</code> laws</a>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">&gt;</span> <span class="st">&quot;1 + (2*3)&quot;</span> <span class="op">&amp;</span> expr <span class="op">%~</span> <span class="fu">id</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="st">&quot;1 + 2 * 3&quot;</span></span></code></pre></div>
<p>If one desires lawful parsing Prisms, their AST representation has to represent white-space and redundant parentheses.</p>
<p>A <code>Prism</code> law that is kept is that if you parse what you built you do get it back:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck.Arbitrary.ADT</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>propParseBack e <span class="ot">=</span> (expr <span class="op">#</span> e) <span class="op">^?</span> expr <span class="op">==</span> <span class="dt">Just</span> e</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    arbitrary <span class="ot">=</span> genericArbitrary</span>
<span id="cb4-7"><a href="#cb4-7"></a>    shrink <span class="ot">=</span> genericShrink</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="op">&gt;</span> quickCheck propParseBack</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="op">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="op">.</span></span></code></pre></div>
<h3 id="caveat-meaninful-parse-errors">Caveat: meaninful parse errors</h3>
<p>When parsing with this <code>Prism</code> fails, it offers no useful error-reporting. But do I believe that this is solvable and I'll address it in future posts.</p>
<h2 id="request-for-feedback">Request for feedback</h2>
<ul>
<li>Do you think that some extra combinators used here (<code>asideFirst</code>, <code>firstOnly</code>, etc) should belong in <a href="http://hackage.haskell.org/package/lens"><code>lens</code></a>?</li>
<li>Or prehaps these combinators should belong in a separate package? How would you call it?</li>
<li>Any suggestions as for naming these combinators? Other code improvements?</li>
<li>Image credit: Does anyone know who is the artist for the opening image? (I found it on <a href="https://www.pinterest.com/pin/800303796254211989/">the internets</a>)</li>
</ul>
<p>Btw: Thanks to Eyal Lotem for reading drafts of this.</p>
<p>Discussion:</p>
<ul>
<li><img src="/images/reddit.svg" alt="reddit" style="width: 20px; display: inline;"/> <a href="https://www.reddit.com/r/haskell/comments/eh4gpg/elegant_ast_parsing_and_building_with_prisms/">r/haskell</a></li>
</ul>
<h2 id="appendix">Appendix</h2>
<h3 id="ast-parse-build-prism-combinators">AST parse-build prism combinators</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- Extend a base parsing prism with applications of an operator</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">infixOpLeftRecursion ::</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="dt">Eq</span> a <span class="ot">=&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    a <span class="ot">-&gt;</span>                        <span class="co">-- The operator&#39;s text</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="dt">Prism&#39;</span> expr (expr, expr) <span class="ot">-&gt;</span> <span class="co">-- The operator constructor&#39;s prism</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="dt">Prism&#39;</span> [a] (expr, [a]) <span class="ot">-&gt;</span>   <span class="co">-- The base parsing prism</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    <span class="dt">Prism&#39;</span> [a] (expr, [a])</span>
<span id="cb5-8"><a href="#cb5-8"></a>infixOpLeftRecursion operatorText cons sub <span class="ot">=</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>    leftRecursion cons</span>
<span id="cb5-10"><a href="#cb5-10"></a>    (aside (_Cons <span class="op">.</span> firstOnly operatorText <span class="op">.</span> sub) <span class="op">.</span> retuple)</span>
<span id="cb5-11"><a href="#cb5-11"></a>    sub</span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">-- Extend a base parsing prism with extensions to its right side</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="ot">leftRecursion ::</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="dt">Prism&#39;</span> whole cons <span class="ot">-&gt;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="dt">Prism&#39;</span> (whole, state) (cons, state) <span class="ot">-&gt;</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="dt">Prism&#39;</span> state (whole, state) <span class="ot">-&gt;</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="dt">Prism&#39;</span> state (whole, state)</span>
<span id="cb5-19"><a href="#cb5-19"></a>leftRecursion cons extend base <span class="ot">=</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>    prism&#39; build (<span class="fu">fmap</span> parseExtends <span class="op">.</span> (<span class="op">^?</span> base))</span>
<span id="cb5-21"><a href="#cb5-21"></a>    <span class="kw">where</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>        build (x, state) <span class="ot">=</span></span>
<span id="cb5-23"><a href="#cb5-23"></a>            <span class="fu">maybe</span></span>
<span id="cb5-24"><a href="#cb5-24"></a>            (base <span class="op">#</span> (x, state))</span>
<span id="cb5-25"><a href="#cb5-25"></a>            (build <span class="op">.</span> (extend <span class="op">#</span>) <span class="op">.</span> (, state)) (x <span class="op">^?</span> cons)</span>
<span id="cb5-26"><a href="#cb5-26"></a>        parseExtends x <span class="ot">=</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>            x <span class="op">^?</span> extend <span class="op">&lt;&amp;&gt;</span> _1 <span class="op">%~</span> (cons <span class="op">#</span>) <span class="op">&amp;</span> <span class="fu">maybe</span> x parseExtends</span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a><span class="co">-- Add an encoding for a sum-type constructor to an existing prism</span></span>
<span id="cb5-30"><a href="#cb5-30"></a><span class="ot">tryMatch ::</span></span>
<span id="cb5-31"><a href="#cb5-31"></a>    <span class="dt">Prism&#39;</span> whole cons <span class="ot">-&gt;</span> <span class="co">-- The sum-type constructor prism</span></span>
<span id="cb5-32"><a href="#cb5-32"></a>    <span class="dt">Prism&#39;</span> src cons <span class="ot">-&gt;</span>   <span class="co">-- Parse the constructor contents</span></span>
<span id="cb5-33"><a href="#cb5-33"></a>    <span class="dt">Prism&#39;</span> src whole <span class="ot">-&gt;</span>  <span class="co">-- Prism to encode the other options</span></span>
<span id="cb5-34"><a href="#cb5-34"></a>    <span class="dt">Prism&#39;</span> src whole</span>
<span id="cb5-35"><a href="#cb5-35"></a>tryMatch cons parse fallback <span class="ot">=</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>    prism&#39; build (\x <span class="ot">-&gt;</span> (x <span class="op">^?</span> parse <span class="op">&lt;&amp;&gt;</span> (cons <span class="op">#</span>)) <span class="op">&lt;|&gt;</span> x <span class="op">^?</span> fallback)</span>
<span id="cb5-37"><a href="#cb5-37"></a>    <span class="kw">where</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>        build x <span class="ot">=</span> <span class="fu">maybe</span> (fallback <span class="op">#</span> x) (parse <span class="op">#</span>) (x <span class="op">^?</span> cons)</span>
<span id="cb5-39"><a href="#cb5-39"></a></span>
<span id="cb5-40"><a href="#cb5-40"></a><span class="co">-- Transform a string into tokens</span></span>
<span id="cb5-41"><a href="#cb5-41"></a><span class="ot">tokens ::</span> <span class="dt">Iso&#39;</span> <span class="dt">String</span> [<span class="dt">String</span>]</span>
<span id="cb5-42"><a href="#cb5-42"></a>tokens <span class="ot">=</span></span>
<span id="cb5-43"><a href="#cb5-43"></a>    iso splitTokens (<span class="fu">foldr</span> addToken <span class="st">&quot;&quot;</span>)</span>
<span id="cb5-44"><a href="#cb5-44"></a>    <span class="kw">where</span></span>
<span id="cb5-45"><a href="#cb5-45"></a>        addToken x <span class="st">&quot;&quot;</span> <span class="ot">=</span> x</span>
<span id="cb5-46"><a href="#cb5-46"></a>        addToken [x] y</span>
<span id="cb5-47"><a href="#cb5-47"></a>            <span class="op">|</span> <span class="dt">Char</span><span class="op">.</span>generalCategory x <span class="op">==</span> <span class="dt">Char</span><span class="op">.</span><span class="dt">OpenPunctuation</span> <span class="ot">=</span> x <span class="op">:</span> y</span>
<span id="cb5-48"><a href="#cb5-48"></a>        addToken x (y<span class="op">:</span>ys)</span>
<span id="cb5-49"><a href="#cb5-49"></a>            <span class="op">|</span> <span class="dt">Char</span><span class="op">.</span>generalCategory y <span class="op">==</span> <span class="dt">Char</span><span class="op">.</span><span class="dt">ClosePunctuation</span> <span class="ot">=</span> x <span class="op">&lt;&gt;</span> (y<span class="op">:</span>ys)</span>
<span id="cb5-50"><a href="#cb5-50"></a>        addToken x y <span class="ot">=</span> x <span class="op">&lt;&gt;</span> <span class="st">&quot; &quot;</span> <span class="op">&lt;&gt;</span> y</span>
<span id="cb5-51"><a href="#cb5-51"></a>        isOp <span class="ot">=</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>            (<span class="ot">`elem`</span> [<span class="dt">Char</span><span class="op">.</span><span class="dt">MathSymbol</span>, <span class="dt">Char</span><span class="op">.</span><span class="dt">OtherPunctuation</span>]) <span class="op">.</span></span>
<span id="cb5-53"><a href="#cb5-53"></a>            <span class="dt">Char</span><span class="op">.</span>generalCategory</span>
<span id="cb5-54"><a href="#cb5-54"></a>        isParen <span class="ot">=</span> (<span class="ot">`elem`</span> <span class="st">&quot;()[]{}&quot;</span>)</span>
<span id="cb5-55"><a href="#cb5-55"></a>        splitTokens <span class="st">&quot;&quot;</span> <span class="ot">=</span> []</span>
<span id="cb5-56"><a href="#cb5-56"></a>        splitTokens (x<span class="op">:</span>s<span class="op">:</span>xs) <span class="op">|</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">isSpace</span> s <span class="ot">=</span> [x] <span class="op">:</span> splitTokens xs</span>
<span id="cb5-57"><a href="#cb5-57"></a>        splitTokens (s<span class="op">:</span>xs) <span class="op">|</span> <span class="dt">Char</span><span class="op">.</span><span class="fu">isSpace</span> s <span class="ot">=</span> splitTokens xs</span>
<span id="cb5-58"><a href="#cb5-58"></a>        splitTokens (x<span class="op">:</span>xs) <span class="op">|</span> isParen x <span class="ot">=</span> [x] <span class="op">:</span> splitTokens xs</span>
<span id="cb5-59"><a href="#cb5-59"></a>        splitTokens (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="cb5-60"><a href="#cb5-60"></a>            <span class="kw">case</span> splitTokens xs <span class="kw">of</span></span>
<span id="cb5-61"><a href="#cb5-61"></a>            [] <span class="ot">-&gt;</span> [[x]]</span>
<span id="cb5-62"><a href="#cb5-62"></a>            ((y<span class="op">:</span>ys) <span class="op">:</span> zs) <span class="op">|</span> <span class="fu">not</span> (isParen y) <span class="op">&amp;&amp;</span> isOp x <span class="op">==</span> isOp y <span class="ot">-&gt;</span> (x<span class="op">:</span>y<span class="op">:</span>ys) <span class="op">:</span> zs</span>
<span id="cb5-63"><a href="#cb5-63"></a>            ys <span class="ot">-&gt;</span> [x] <span class="op">:</span> ys</span></code></pre></div>
<ul>
<li>The <code>retuple</code> <code>Iso</code> was <a href="codecs-as-prisms#parse-build-prism-combinators">defined in the previous post</a></li>
<li><code>tryMatch</code> takes two prisms from the unparsed source and from the resulting structure to the matched pattern. If there were optics for inversed prisms and <a href="https://stackoverflow.com/questions/59426379/optic-for-partial-conversion-on-both-sides/59441415#59441415">partial isomorphisms</a> then these could be combined into one argument and the existing <a href="http://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Combinators.html#v:failing"><code>failing</code></a> combinator could replace <code>tryMatch</code>.</li>
</ul>]]></content>
  </entry>
  <entry>
      <title>Parsers and Builders as Prisms</title>
      <link href="https://yairchu.github.io/posts/codecs-as-prisms"/>
      <id>https://yairchu.github.io/posts/codecs-as-prisms</id>
      <updated>2019-12-19T00:00:SZ</updated>
      <category term="code"/>
      <category term="declarative"/>
      <category term="haskell"/>
      <category term="python"/>
      <category term="optics"/>
      <category term="parsing"/>
      <category term="construct"/>
      <summary>Declarative parsing and pretty printing</summary>
      <content type="html"><![CDATA[<p>Serialization and deserialization are tedious tasks, often riddled with boiler-plate and bug-prone code. There's a plethora of tools, such as parser combinator libraries, which aim to assist us in some of these tasks, and it seems that new tools never stop popping up. This hints that there are probably no well known satisfactory solutions to these problems, which probably means that most of these tools are ad-hoc rather than principled high-quality solutions.</p>
<p>Are there no good solutions out there? Actually, there are!</p>
<p>Back when I was programming in Python, I have used <a href="https://construct.readthedocs.io/en/latest/intro.html">Construct</a> to great satisfaction. But for a long time now I have been using Haskell, and have found no equivalent to it, <a href="https://stackoverflow.com/questions/1225053/haskell-equivalent-of-pythons-construct">which I've actually wanted for more than 10 years</a>! So perhaps I should start looking into making one? Hence this post.</p>
<p>In this post we'll introduce Construct's declarative approach and then discuss how to implement an equivalent principled solution in Haskell, based on optics.</p>
<h2 id="construct-declarative-parsers-and-builders">Construct: declarative parsers and builders</h2>
<p>Construct is declarative.</p>
<p>What do I mean by that? A declarative implementation of a parser should describe the format, not how to parse it!</p>
<p>From this description, the computer will automatically figure out how to parse. Not only that, it will also know how to build, and ideally even generate extra artifacts like documentation for the format!</p>
<p>Here's how Construct defines the format of IPv4 packets:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>ipv4 <span class="op">=</span> Struct(</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="st">&quot;header&quot;</span> <span class="op">/</span> BitStruct(</span>
<span id="cb1-3"><a href="#cb1-3"></a>        <span class="st">&quot;version&quot;</span> <span class="op">/</span> Const(<span class="dv">4</span>, Nibble),</span>
<span id="cb1-4"><a href="#cb1-4"></a>        <span class="st">&quot;length&quot;</span> <span class="op">/</span> ExprAdapter(Nibble,</span>
<span id="cb1-5"><a href="#cb1-5"></a>            decoder <span class="op">=</span> <span class="kw">lambda</span> obj, ctx: obj <span class="op">*</span> <span class="dv">4</span>,</span>
<span id="cb1-6"><a href="#cb1-6"></a>            encoder <span class="op">=</span> <span class="kw">lambda</span> obj, ctx: obj <span class="op">//</span> <span class="dv">4</span>,</span>
<span id="cb1-7"><a href="#cb1-7"></a>        ),</span>
<span id="cb1-8"><a href="#cb1-8"></a>    ),</span>
<span id="cb1-9"><a href="#cb1-9"></a>    ...</span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="st">&quot;total_length&quot;</span> <span class="op">/</span> Int16ub,</span>
<span id="cb1-11"><a href="#cb1-11"></a>    ...</span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="st">&quot;options&quot;</span> <span class="op">/</span> Bytes(this.header.length <span class="op">-</span> <span class="dv">20</span>),</span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="st">&quot;body&quot;</span> <span class="op">/</span> Bytes(this.total_length <span class="op">-</span> this.header.length),</span>
<span id="cb1-14"><a href="#cb1-14"></a>)</span></code></pre></div>
<p>In this simple declaration we created a parser, builder, and the data type for IPv4 packets!</p>
<p>Also, I'd like to highlight the richness of the format. It isn't a simple "struct" with fields of known types, but rather a "dependently-typed" one, where the size of the <code>options</code> field depends on the value of <code>header.length</code>! Haskell parser combinators libraries which support such dependencies tend to identify as <a href="http://hackage.haskell.org/package/parsec">"monadic parser combinators" libraries</a>, in constrast to <a href="http://hackage.haskell.org/package/regex-applicative">"applicative parser combinators"</a> which don't support them.</p>
<h2 id="parsers-and-builders-as-prisms">Parsers and builders as prisms</h2>
<p>What is the essence of parsing and building?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Codec</span> myType encoded <span class="ot">=</span> <span class="dt">Codec</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    {<span class="ot"> build ::</span> myType <span class="ot">-&gt;</span> encoded</span>
<span id="cb2-3"><a href="#cb2-3"></a>    ,<span class="ot"> parse ::</span> encoded <span class="ot">-&gt;</span> <span class="dt">Maybe</span> myType</span>
<span id="cb2-4"><a href="#cb2-4"></a>    }</span></code></pre></div>
<p>(Caveat: one may desire meaningful parse errors using <code>Either ParseError</code> rather of <code>Maybe</code>. We'll ignore this issue for now)</p>
<p>Looking for a principled solution, one may notice that this type is equivalent to <a href="https://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html"><code>Prism</code></a> from the popular <a href="https://hackage.haskell.org/package/lens"><code>lens</code></a> package!</p>
<blockquote>
<p>‘There are only two hard things in Computer Science: cache invalidation and naming things.’ - Phil Karlton</p>
</blockquote>
<p>Naming things is hard, and we want principled approaches and code re-use, so we'll choose to use the existing <code>Prism</code> rather than make an equivalent new ad-hoc type. Hopefully this will also enable enjoying the fruits of the existing <code>lens</code> eco-system.</p>
<p>Let's demonstrate with a simplified IP-like protocol:</p>
<ul>
<li>Word8: The constant 7</li>
<li>Word16: Body length</li>
<li>Word16: Origin address</li>
<li>Word16: Destination address</li>
<li>Body-length bytes: Packet body</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">&gt;</span> simplifiedIp <span class="op">#</span> ((<span class="dv">2</span>, <span class="dv">3</span>), <span class="st">&quot;Hello World!&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="st">&quot;\a\NUL\f\NUL\STX\NUL\ETXHello World!&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">&gt;</span> <span class="st">&quot;\a\NUL\f\NUL\STX\NUL\ETXHello World!&quot;</span> <span class="op">^?</span> simplifiedIp</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="dt">Just</span> ((<span class="dv">2</span>,<span class="dv">3</span>),<span class="st">&quot;Hello World!&quot;</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="ot">simplifiedIp ::</span> <span class="dt">Prism&#39;</span> <span class="dt">ByteString</span> ((<span class="dt">Word16</span>, <span class="dt">Word16</span>), <span class="dt">ByteString</span>)</span>
<span id="cb3-8"><a href="#cb3-8"></a>simplifiedIp <span class="ot">=</span> takeSimplifiedIp <span class="op">.</span> secondOnly <span class="st">&quot;&quot;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="ot">takeSimplifiedIp ::</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="dt">Prism&#39;</span> <span class="dt">ByteString</span> (((<span class="dt">Word16</span>, <span class="dt">Word16</span>), <span class="dt">ByteString</span>), <span class="dt">ByteString</span>)</span>
<span id="cb3-12"><a href="#cb3-12"></a>takeSimplifiedIp <span class="ot">=</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>    _Cons <span class="op">.</span> firstOnly <span class="dv">7</span> <span class="op">.</span> <span class="co">-- Remove the constant byte 7</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    takeWord16 <span class="op">.</span>          <span class="co">-- (bodyLen, rest)</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>    aside (takeWord16 <span class="op">.</span> aside takeWord16) <span class="op">.</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>                          <span class="co">-- (bodyLen, (origin, (dest, rest)))</span></span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="co">-- Reordering (this is somewhat painful):</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>    aside retuple <span class="op">.</span>       <span class="co">-- (bodyLen, ((origin, dest), rest))</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>    retuple <span class="op">.</span>             <span class="co">-- ((bodyLen, (origin, dest)), rest)</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>    asideFirst swapped <span class="op">.</span>  <span class="co">-- (((origin, dest), bodyLen), rest)</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>    from retuple <span class="op">.</span>        <span class="co">-- ((origin, dest), (bodyLen, rest))</span></span>
<span id="cb3-23"><a href="#cb3-23"></a></span>
<span id="cb3-24"><a href="#cb3-24"></a>    aside takeBytes <span class="op">.</span>     <span class="co">-- ((origin, dest), (body, remainder))</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>    retuple               <span class="co">-- (((origin, dest), body), remainder)</span></span></code></pre></div>
<p>This uses some combinators from <code>Control.Lens</code> and some extra combinators defined below:</p>
<h3 id="parse-build-prism-combinators">Parse-build prism combinators</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">firstOnly ::</span> <span class="dt">Eq</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">Prism&#39;</span> (e, a) a</span>
<span id="cb4-2"><a href="#cb4-2"></a>firstOnly x <span class="ot">=</span> asideFirst (only x) <span class="op">.</span> iso <span class="fu">snd</span> ((,) ())</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="ot">secondOnly ::</span> <span class="dt">Eq</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">Prism&#39;</span> (a, e) a</span>
<span id="cb4-5"><a href="#cb4-5"></a>secondOnly x <span class="ot">=</span> swapped <span class="op">.</span> firstOnly x</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="ot">asideFirst ::</span> <span class="dt">APrism</span> s t a b <span class="ot">-&gt;</span> <span class="dt">Prism</span> (s, e) (t, e) (a, e) (b, e)</span>
<span id="cb4-8"><a href="#cb4-8"></a>asideFirst l <span class="ot">=</span> swapped <span class="op">.</span> aside l <span class="op">.</span> swapped</span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">-- Tuple shuffling Iso</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="ot">retuple ::</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="dt">Iso</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>    (a0, (a1, a2)) (b0, (b1, b2))</span>
<span id="cb4-14"><a href="#cb4-14"></a>    ((a0, a1), a2) ((b0, b1), b2)</span>
<span id="cb4-15"><a href="#cb4-15"></a>retuple <span class="ot">=</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>    iso</span>
<span id="cb4-17"><a href="#cb4-17"></a>    (\(w0, (w1, r)) <span class="ot">-&gt;</span> ((w0, w1), r))</span>
<span id="cb4-18"><a href="#cb4-18"></a>    (\((w0, w1), r) <span class="ot">-&gt;</span> (w0, (w1, r)))</span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a><span class="ot">takeWord16 ::</span> <span class="dt">Prism&#39;</span> <span class="dt">ByteString</span> (<span class="dt">Word16</span>, <span class="dt">ByteString</span>)</span>
<span id="cb4-21"><a href="#cb4-21"></a>takeWord16 <span class="ot">=</span> _Cons <span class="op">.</span> aside _Cons <span class="op">.</span> retuple <span class="op">.</span> asideFirst (from word16Bytes)</span>
<span id="cb4-22"><a href="#cb4-22"></a></span>
<span id="cb4-23"><a href="#cb4-23"></a><span class="ot">word16Bytes ::</span> <span class="dt">Iso&#39;</span> <span class="dt">Word16</span> (<span class="dt">Word8</span>, <span class="dt">Word8</span>)</span>
<span id="cb4-24"><a href="#cb4-24"></a>word16Bytes <span class="ot">=</span></span>
<span id="cb4-25"><a href="#cb4-25"></a>    iso</span>
<span id="cb4-26"><a href="#cb4-26"></a>    ((both <span class="op">%~</span> <span class="fu">fromIntegral</span>) <span class="op">.</span> (<span class="ot">`divMod`</span> <span class="dv">256</span>))</span>
<span id="cb4-27"><a href="#cb4-27"></a>    (\(w1, w0) <span class="ot">-&gt;</span> <span class="fu">fromIntegral</span> w1 <span class="op">*</span> <span class="dv">256</span> <span class="op">+</span> <span class="fu">fromIntegral</span> w0)</span>
<span id="cb4-28"><a href="#cb4-28"></a></span>
<span id="cb4-29"><a href="#cb4-29"></a><span class="ot">takeBytes ::</span></span>
<span id="cb4-30"><a href="#cb4-30"></a>    <span class="dt">Integral</span> a <span class="ot">=&gt;</span></span>
<span id="cb4-31"><a href="#cb4-31"></a>    <span class="dt">Prism&#39;</span> (a, <span class="dt">ByteString</span>) (<span class="dt">ByteString</span>, <span class="dt">ByteString</span>)</span>
<span id="cb4-32"><a href="#cb4-32"></a>takeBytes <span class="ot">=</span></span>
<span id="cb4-33"><a href="#cb4-33"></a>    prism&#39;</span>
<span id="cb4-34"><a href="#cb4-34"></a>    ( \(x, y) <span class="ot">-&gt;</span></span>
<span id="cb4-35"><a href="#cb4-35"></a>        (<span class="fu">fromIntegral</span> (<span class="dt">ByteString</span><span class="op">.</span><span class="fu">length</span> x), x <span class="op">&lt;&gt;</span> y))</span>
<span id="cb4-36"><a href="#cb4-36"></a>    (\(count, x) <span class="ot">-&gt;</span></span>
<span id="cb4-37"><a href="#cb4-37"></a>        <span class="dt">ByteString</span><span class="op">.</span><span class="fu">splitAt</span> (<span class="fu">fromIntegral</span> count) x <span class="op">&lt;$</span></span>
<span id="cb4-38"><a href="#cb4-38"></a>        guard (<span class="fu">fromIntegral</span> count <span class="op">&lt;=</span> <span class="dt">ByteString</span><span class="op">.</span><span class="fu">length</span> x))</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>We've succesfully crafted prisms to parse and build our structure!</p>
<p>Now let's review some drawbacks of the presented approach:</p>
<ul>
<li>We used anonymous tuples where Construct uses named fields
<ul>
<li>Using tuples isn't so type-safe nor is it descriptive</li>
<li>Reordering our tuples to fit the combinators was painful</li>
<li>To do what Construct does, we would need structural records, where we can add fields to the structure one at a time (note that this may be possible using a package such as <a href="https://hackage.haskell.org/package/vinyl-0.12.0/docs/Data-Vinyl-Tutorial-Overview.html">vinyl</a>?)</li>
</ul></li>
<li>Our parsers don't perform error reporting
<ul>
<li>When writing parsers for programming languages this is quite crucial! (Imagine getting a syntax error with the compiler not even pointing out what line it's at)</li>
</ul></li>
</ul>
<p>I believe that both of these problems can be solved, resulting in a powerful and ergonomic principled solution. In my next post I'll describe an approach to add error reporting to our prisms.</p>
<p>Notes:</p>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2004/01/picklercombinators.pdf">AJ. Kennedy's "Pickler Combinators" paper (JFP 2004)</a> described parsing+building combinators in Haskell using a custom data type (not using prisms) and demonstrated some more useful combinators for parsing</li>
<li>Apparently T. Filiba, the author of Construct, <a href="http://tomerfiliba.com/blog/ConstructPlusPlus/">has attempted re-implementing it in Haskell in 2014</a>, but gave up</li>
<li>Image credit: <a href="https://commons.wikimedia.org/wiki/File:Dispersive_prism.png">Kelvinsong [CC0]</a></li>
</ul>
<p>Discussion:</p>
<ul>
<li><img src="/images/twitter-logo.png" alt="reddit" style="width: 20px; display: inline;"/> <a href="https://twitter.com/yairchu/status/1207947943552192512">Twitter</a></li>
<li><img src="/images/reddit.svg" alt="reddit" style="width: 20px; display: inline;"/> <a href="https://www.reddit.com/r/haskell/comments/ed7k24/parsers_and_builders_as_prisms/">r/haskell</a></li>
</ul>]]></content>
  </entry>
  <entry>
      <title>Why does your programming language have five command line tools?</title>
      <link href="https://yairchu.github.io/posts/the-five-tools"/>
      <id>https://yairchu.github.io/posts/the-five-tools</id>
      <updated>2019-11-07T00:00:SZ</updated>
      <category term="code"/>
      <category term="haskell"/>
      <category term="python"/>
      <category term="c++"/>
      <category term="rust"/>
      <category term="stack"/>
      <summary>Why do programming languages have so many build tools</summary>
      <content type="html"><![CDATA[<p>Whichever programming language you use, its eco-system probably consists of a plethora of confusing command line tools which you might have needed to use to actually make software with it.</p>
<h2 id="compiling-your-program">Compiling your program</h2>
<p>You need something to compile or interpret your program. In Haskell this is <code>ghc</code>, in Python it's <code>python</code>. In C++ it's <del><code>gcc</code></del> <del><code>clang</code></del> your IDE.</p>
<h2 id="compiling-a-program-which-consists-of-several-modules">Compiling a program which consists of several modules</h2>
<p>In some languages, the compiler only compiles a single source file. If we split our code to several modules, we need a tool to run the compiler for each one. In Haskell that's <code>cabal</code> (and later also <code>ghc --make</code>), in Python it was always baked in to the interpreter. In C++ this is the reason you just use an IDE.</p>
<h2 id="package-manager">Package manager</h2>
<p>You want to use libraries. In the old days folks downloaded installers or source packages from the internet and executed their install scripts, but the current trend is to invoke the package manager which magically installs a package along with its transitive dependencies for you.</p>
<p>In Haskell that's <code>cabal-install</code>. In Python it was <code>easy_install</code> and nowadays it seems to be <code>pip</code>. In C++ you simply try to avoid using libraries.</p>
<h3 id="the-package-manager-fallacy">The package manager fallacy</h3>
<p>A problem with this paradigm arises when you work on two projects which depend on different versions of the same library. This is a conflict!</p>
<p>The problem is even more subtle as versions of the transitive dependencies may occasionally matter too.</p>
<p>This is the reason that we need even more tools.</p>
<h3 id="the-sandbox">The "Sandbox"</h3>
<p>This tool allows different projects to use distinct versions of libraries. In Haskell this is <code>cabal-v2</code>, in Python it was <code>virtualenv</code> and nowaday it seems to be <code>venv</code>.</p>
<h3 id="the-libraries-sandbox-fallacy">The Libraries Sandbox fallacy</h3>
<p>The libraries aren't all of the dependencies. The specific version of the programming language's compiler/interpreter itself also tends to matter quite a lot!</p>
<p>This is the reason that we need even more tools.</p>
<h2 id="reproducible-build">Reproducible Build</h2>
<p><img src="/images/turtles-all-the-way-down.jpg" alt="Turtles all the way down" /></p>
<p>You also want to be able to express which exact version of your compiler/etc you are using, and have your tool do all the rest (get this compiler version, your dependencies, and build your program for you).</p>
<p>You want the definitions to be stored in your source repository so that you could easily go and build the old versions of your project just like you did when you implemented them.</p>
<p>In Haskell the tool for this is generally <code>stack</code> (which actually existed before <code>cabal-v2</code>) or <code>nix</code>. In Python folks keep several toolset installations (i.e <code>python2</code> and <code>python3</code>) and manually invoke the right one. In C++ to build your old code you keep around an old computer.</p>
<p>In a perfect world the "reproducible build" tool should be the only tool you need.</p>
<p>The existence of the previous partial solutions is an awkward artifact of history which represents the order of iterative discovery and partial solutions to this problem space.</p>
<h3 id="points-for-rust">Points for Rust</h3>
<p><img src="/images/dab-emoji.jpg" alt="Dab Emoji" style="width: 150px;"/></p>
<p>Hindsight is 20/20.</p>
<p>Unlike Python, Haskell, and other languages which each developed their five tools, Rust, a new-comer modern programming language skipped this baggage and does offer a single reproducible build tool to rule them all - <code>cargo</code>.</p>
<h2 id="is-that-all">Is that all</h2>
<p><img src="/images/yo-dawg-tool-to-get-tools.jpg" alt="Yo dawg" /></p>
<p>Is that all? Or do we also need a tool to specify the exact version of our reproducible build tool?</p>
<p>In a perfect world you wouldn't need that, but unfortunately the world is not perfect. Haskell's <code>stack</code>'s new versions don't support some features of the definition files (<code>stack.yaml</code>) of its older versions and vice versa. To solve this problem without an additional layer the reproducible build tool must be solid. It has to be backwards compatible with its older versions and also not have any weird behaviors (a bug-feature) that people rely on. Otherwise we'd need to keep piling layers.</p>
<p>Image sources:</p>
<ul>
<li><a href="https://imgur.com/gallery/BwYFH0F">Duct-tape car</a></li>
<li><a href="https://en.wikipedia.org/wiki/Turtles_all_the_way_down#/media/File:River_terrapin.jpg">Turtles</a></li>
<li><a href="https://www.change.org/p/apple-add-the-dab-emoji-to-ios">Dab Emoji</a></li>
</ul>]]></content>
  </entry>
  <entry>
      <title>The four simple ways to encode sum-types</title>
      <link href="https://yairchu.github.io/posts/sum-type-encodings"/>
      <id>https://yairchu.github.io/posts/sum-type-encodings</id>
      <updated>2019-11-06T00:00:SZ</updated>
      <category term="code"/>
      <category term="expr-problem"/>
      <category term="sum-types"/>
      <category term="haskell"/>
      <category term="default-sigs"/>
      <summary>How and why to encode sum types?</summary>
      <content type="html"><![CDATA[<p>There are four simple ways to encode sum types:</p>
<ul>
<li>Directly, if your programming language supports them</li>
<li>"Church encoding"</li>
<li>"Final style"</li>
<li>The OO pattern</li>
</ul>
<p>We'll introduce them and discuss their pros and cons, focusing on open (extensible) sum-types.</p>
<h2 id="direct">Direct</h2>
<p>All the up and coming programming languages support sum types, by feature if not by name:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">Language</th>
<th style="text-align: left;">Feature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">F#</td>
<td style="text-align: left;"><a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions">Discriminated Unions</a></td>
</tr>
<tr class="even">
<td style="text-align: right;">Elm</td>
<td style="text-align: left;"><a href="https://guide.elm-lang.org/types/custom_types.html">Variants</a></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Rust</td>
<td style="text-align: left;"><a href="https://doc.rust-lang.org/book/ch06-00-enums.html">Enumerations</a></td>
</tr>
<tr class="even">
<td style="text-align: right;">Swift</td>
<td style="text-align: left;"><a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html">Enumerations</a></td>
</tr>
<tr class="odd">
<td style="text-align: right;">Kotlin</td>
<td style="text-align: left;"><a href="https://kotlinlang.org/docs/reference/sealed-classes.html">Sealed Classes</a></td>
</tr>
<tr class="even">
<td style="text-align: right;">Haskell</td>
<td style="text-align: left;"><a href="https://wiki.haskell.org/Algebraic_data_type">Algebraic Data Types</a></td>
</tr>
</tbody>
</table>
<p>We'll use Haskell to demonstrate them:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Shape</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="ot">=</span> <span class="dt">Rect</span> {<span class="ot"> width ::</span> <span class="dt">Float</span>,<span class="ot"> height ::</span> <span class="dt">Float</span> }</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="op">|</span> <span class="dt">Circle</span> {<span class="ot"> radius ::</span> <span class="dt">Float</span> }</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">area ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>area (<span class="dt">Rect</span> w h) <span class="ot">=</span> w <span class="op">*</span> h</span>
<span id="cb1-7"><a href="#cb1-7"></a>area (<span class="dt">Circle</span> r) <span class="ot">=</span> <span class="fu">pi</span> <span class="op">*</span> r <span class="op">*</span> r</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="op">&gt;</span> area (<span class="dt">Rect</span> <span class="dv">3</span> <span class="dv">5</span>)</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="dv">15</span></span></code></pre></div>
<h2 id="church-encoding">Church encoding</h2>
<p>How would we encode our type in legacy languages which don't support sum types?</p>
<p>Famous minimalist <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a> has devised a method:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">data</span> <span class="dt">ShapeHandlers</span> r <span class="ot">=</span> <span class="dt">ShapeHandlers</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    {<span class="ot"> handleRect ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> r</span>
<span id="cb2-5"><a href="#cb2-5"></a>    ,<span class="ot"> handleCircle ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> r</span>
<span id="cb2-6"><a href="#cb2-6"></a>    }</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">type</span> <span class="dt">Shape</span> <span class="ot">=</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">ShapeHandlers</span> a <span class="ot">-&gt;</span> a)</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ot">rect ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Shape</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>rect w h handlers <span class="ot">=</span> handleRect handlers w h</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="ot">circle ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Shape</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>circle r handlers <span class="ot">=</span> handleCircle handlers r</span>
<span id="cb2-15"><a href="#cb2-15"></a></span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="ot">area ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>area shape <span class="ot">=</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    shape</span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="dt">ShapeHandlers</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>    { handleRect <span class="ot">=</span> \w h <span class="ot">-&gt;</span> w <span class="op">*</span> h</span>
<span id="cb2-21"><a href="#cb2-21"></a>    , handleCircle <span class="ot">=</span> \r <span class="ot">-&gt;</span> <span class="fu">pi</span> <span class="op">*</span> r <span class="op">*</span> r</span>
<span id="cb2-22"><a href="#cb2-22"></a>    }</span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="op">&gt;</span> area (rect <span class="dv">3</span> <span class="dv">5</span>)</span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="dv">15</span></span></code></pre></div>
<p>While originally intended for use in his minimal programming language "Lambda Calculus", this encoding is suitable for most popular languages. Java/C# supports it via abstract generic methods. In C++ or Go we'll have to resort to casts or side-effects to encode this (the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor pattern</a>).</p>
<h2 id="final-style-extending-church-encodings-using-type-classes">Final style: Extending church-encodings using type classes</h2>
<p>We can encode the record from the church encoding using a type-class:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">class</span> <span class="dt">ShapeHandlers</span> r <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">    rect ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> r</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">    circle ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> r</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">type</span> <span class="dt">Shape</span> <span class="ot">=</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">ShapeHandlers</span> a <span class="ot">=&gt;</span> a)</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">newtype</span> <span class="dt">Area</span> <span class="ot">=</span> <span class="dt">Area</span> {<span class="ot"> area ::</span> <span class="dt">Float</span> }</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">instance</span> <span class="dt">ShapeHandlers</span> <span class="dt">Area</span> <span class="kw">where</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    rect w h <span class="ot">=</span> <span class="dt">Area</span> (w <span class="op">*</span> h)</span>
<span id="cb3-13"><a href="#cb3-13"></a>    circle r <span class="ot">=</span> <span class="dt">Area</span> (<span class="fu">pi</span> <span class="op">*</span> r <span class="op">*</span> r)</span>
<span id="cb3-14"><a href="#cb3-14"></a></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="op">&gt;</span> area (rect <span class="dv">3</span> <span class="dv">5</span>)</span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="dv">15</span></span></code></pre></div>
<p>The main benefit of using this encoding is that type class constraints are trivially composable, which translates to encoding extensible sum-types! For example: <code>(forall a. (ShapeHandlers a, MoreHandlers a) =&gt; a)</code></p>
<p>With a small modification (avoiding universal quantification) this becomes Carette et al's <a href="http://okmij.org/ftp/tagless-final/index.html">"Final Style"</a>, which is also commonly known as "<code>mtl</code> style".</p>
<p>A similar encoding in OO languages, using interfaces instead of type classes is Oliviera et al's <a href="https://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf">"Object Algebras"</a>.</p>
<h2 id="the-oo-pattern">The OO pattern</h2>
<p>This is a common way to represent sum types in object oriented languages:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">data</span> <span class="dt">Rect</span> <span class="ot">=</span> <span class="dt">Rect</span> {<span class="ot"> width ::</span> <span class="dt">Float</span>,<span class="ot"> height ::</span> <span class="dt">Float</span> }</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">data</span> <span class="dt">Circle</span> <span class="ot">=</span> <span class="dt">Circle</span> {<span class="ot"> radius ::</span> <span class="dt">Float</span> }</span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">class</span> <span class="dt">Area</span> a <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="ot">    area ::</span> a <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="kw">instance</span> <span class="dt">Area</span> <span class="dt">Rect</span> <span class="kw">where</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    area (<span class="dt">Rect</span> w h) <span class="ot">=</span> w <span class="op">*</span> h</span>
<span id="cb4-10"><a href="#cb4-10"></a></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="kw">instance</span> <span class="dt">Area</span> <span class="dt">Circle</span> <span class="kw">where</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    area (<span class="dt">Circle</span> r) <span class="ot">=</span> <span class="fu">pi</span> <span class="op">*</span> r <span class="op">*</span> r</span>
<span id="cb4-13"><a href="#cb4-13"></a></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="op">&gt;</span> area (<span class="dt">Rect</span> <span class="dv">3</span> <span class="dv">5</span>)</span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="dv">15</span></span></code></pre></div>
<p>This encoding is naturally open! We can add shapes as we please, and in posh languages which support type-classes or traits we can also add more operations on them without modifying existing code.</p>
<h2 id="putting-these-approaches-to-the-test">Putting these approaches to the test</h2>
<p>Let's explore how these approaches fare against some simple challenges.</p>
<h3 id="supporting-new-shapes">Supporting new shapes</h3>
<p>Suppose we wanted to write code that can support more types of shapes, without modifying our shape data definition (aka the <a href="https://en.wikipedia.org/wiki/Expression_problem">Expression problem</a>).</p>
<p>The direct sum-type can't be extended, nor can its church encoding. But the final and OO styles can.</p>
<p>Final style:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> <span class="dt">CompositeHandler</span> r <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">    composite ::</span> r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">instance</span> <span class="dt">CompositeHandler</span> <span class="dt">Area</span> <span class="kw">where</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    composite (<span class="dt">Area</span> x) (<span class="dt">Area</span> y) <span class="ot">=</span> <span class="dt">Area</span> (x <span class="op">+</span> y)</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="op">&gt;</span> area (composite (rect <span class="dv">3</span> <span class="dv">5</span>) (circle <span class="dv">1</span>))</span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="fl">18.141592</span></span></code></pre></div>
<p>OO style:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">data</span> <span class="dt">Composite</span> a b <span class="ot">=</span> <span class="dt">Composite</span> {<span class="ot"> first ::</span> a,<span class="ot"> second ::</span> b }</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">instance</span> (<span class="dt">Area</span> a, <span class="dt">Area</span> b) <span class="ot">=&gt;</span> <span class="dt">Area</span> (<span class="dt">Composite</span> a b) <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    area (<span class="dt">Composite</span> x y) <span class="ot">=</span> area x <span class="op">+</span> area y</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="op">&gt;</span> area (<span class="dt">Composite</span> (<span class="dt">Rect</span> <span class="dv">3</span> <span class="dv">5</span>) (<span class="dt">Circle</span> <span class="dv">1</span>))</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="fl">18.141592</span></span></code></pre></div>
<h3 id="collections">Collections</h3>
<p>If we wanted to encode a list of shapes:</p>
<ul>
<li>A final style list, <code>[(forall a. (ShapeHandlers a, CompositeHandler a) =&gt; a)]</code>, uses a universal quantifier and closes the list of supported variants</li>
<li>An OO style list will have to use an existensial quantifier and close the list of supported operations</li>
</ul>
<h3 id="operations-on-more-than-one-value">Operations on more than one value</h3>
<p>The <code>area</code> operation discussed earlier converts a given value to a result. But what if we wanted an operation that processes two shapes, like generating a diff of them?</p>
<p>This is where all styles discussed above fall short as far as I'm aware.</p>
<h2 id="the-fifth-approach-composition-of-atoms">The fifth approach: Composition of atoms</h2>
<p>All the approaches discussed above failed when put to the test. The following approach fares better -</p>
<p>We build upon the OO approach's basic shapes and combine them into a concrete <code>Shape</code> sum type:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric, DeriveAnyClass #-}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">data</span> <span class="dt">Shape</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="ot">=</span> <span class="dt">SRect</span> <span class="dt">Rect</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    <span class="op">|</span> <span class="dt">SCircle</span> <span class="dt">Circle</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Area</span>)</span></code></pre></div>
<p>We use <code>Generic</code> and <code>DefaultSignatures</code> based derivations to derive our class instances (the derivation of <code>Area</code> is left as an exercise for the reader).</p>
<p>This approach allows us to implement our basic types, operations, and instances in a modular way, while only closing the type at the top-level. It does allow us to implement operations on more than one value (such as diffs), and we can encode a list in either of the styles supported by Final or OO styles.</p>
<p>Discussion:</p>
<ul>
<li><img src="/images/reddit.svg" alt="reddit" style="width: 20px; display: inline;"/> <a href="https://www.reddit.com/r/haskell/comments/dsgr0r/the_four_simple_ways_to_encode_sumtypes/">r/haskell</a></li>
</ul>
<p>(image credit: <a href="https://commons.wikimedia.org/wiki/File:Loc_Bloc_example_1_of_Disney.JPG">MissMarvel50sWorld</a>)</p>]]></content>
  </entry>
  <entry>
      <title>Nicer Data Types a la Carte with DefaultSignatures</title>
      <link href="https://yairchu.github.io/posts/dtalc-with-defaultsigs"/>
      <id>https://yairchu.github.io/posts/dtalc-with-defaultsigs</id>
      <updated>2019-10-02T00:00:SZ</updated>
      <category term="code"/>
      <category term="expr-problem"/>
      <category term="haskell"/>
      <category term="default-sigs"/>
      <summary>On using DefaultSignatures to improve DTALC</summary>
      <content type="html"><![CDATA[<p>Back in 2008, Swierstra's Functional Pearl <a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf"><em>Data Types a la Carte</em></a> showed how to construct the following data structure:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>from simple and re-usable individual components:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">newtype</span> <span class="dt">Val</span> e <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">data</span>    <span class="dt">Add</span> e <span class="ot">=</span> <span class="dt">Add</span> e e <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">type</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Val</span> <span class="op">:+:</span> <span class="dt">Add</span>)</span></code></pre></div>
<p>(<a href="http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Fix"><code>Fix</code></a> is available in the <a href="http://hackage.haskell.org/package/recursion-schemes"><code>recursion-schemes</code></a> package and <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#t::-43-:"><code>:+:</code></a> is available from <code>GHC.Generics</code>)</p>
<h2 id="the-good">The Good</h2>
<p>This construction allows to write clean and re-usable modular code. For example we can implement evaluation of expressions like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Eval</span> f <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">    evalAlgebra ::</span> f <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>eval (<span class="dt">Fix</span> expr) <span class="ot">=</span> evalAlgebra (<span class="fu">fmap</span> eval expr)</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">instance</span> (<span class="dt">Eval</span> f, <span class="dt">Eval</span> g) <span class="ot">=&gt;</span> <span class="dt">Eval</span> (f <span class="op">:+:</span> g) <span class="kw">where</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    evalAlgebra (<span class="dt">L1</span> x) <span class="ot">=</span> evalAlgebra x</span>
<span id="cb3-8"><a href="#cb3-8"></a>    evalAlgebra (<span class="dt">R1</span> y) <span class="ot">=</span> evalAlgebra y</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Val</span> <span class="kw">where</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    evalAlgebra (<span class="dt">Val</span> x) <span class="ot">=</span> x</span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Add</span> <span class="kw">where</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    evalAlgebra (<span class="dt">Add</span> x y) <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>The beautiful part, which makes this a functional pearl, is that the <code>Eval</code> instances of <code>Val</code> and <code>Add</code> are usable not just for the <code>Expr</code> type defined above, but also for any other expression language which re-uses them, such as:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> <span class="dt">Expr2</span> <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Val</span> <span class="op">:+:</span> <span class="dt">Add</span> <span class="op">:+:</span> <span class="dt">Mul</span> <span class="op">:+:</span> <span class="dt">Pow</span> <span class="op">:+:</span> <span class="dt">Etc</span>)</span></code></pre></div>
<h2 id="the-ugly">The Ugly</h2>
<p>How would we represent an expression, such as <code>1 + 2</code> in the type defined above?</p>
<p>The simple way to do it is <code>Fix (R1 (Fix (L1 (Val 1)) `Add` Fix (L1 (Val 2))))</code>.</p>
<p>The usages of <code>Fix</code>, <code>R1</code> and <code>L1</code> are cumbersome, so to make things easier Swiestra showed how to write the expression as <code>val 1 `add` val 2</code> using an additional type-class and lifting functions per constructor. This makes writing terms convinient, but a few problems remain unsolved:</p>
<ul>
<li>For expression types with many possible constructors, we pay a performance penalty for this representation, when compared to a single "flat expression algebra"</li>
<li><code>Expr</code>'s <code>Show</code> is very cumbersome</li>
</ul>
<h3 id="bringing-the-benefits-of-data-types-a-la-carte-to-simpler-representations">Bringing the benefits of Data Types a la Carte to simpler representations</h3>
<p>A few years after the paper, in 2011, <code>DefaultSignatures</code> <a href="https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/release-7-2-1.html">were added in GHC 7.2</a>. These enable a more direct construction of <code>Expr</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="ot">=</span> <span class="dt">EVal</span> (<span class="dt">Val</span> a) <span class="op">|</span> <span class="dt">EAdd</span> (<span class="dt">Add</span> a)</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="kw">deriving</span> (<span class="dt">Generic1</span>, <span class="dt">Functor</span>, <span class="dt">Eval</span>)</span></code></pre></div>
<p>Of note here is the derivation of <code>Eval</code> (using <code>DeriveAnyClass</code>). Making <code>Eval</code> derivable is a simple matter of adding default method implementations in the <code>Eval</code> class along with two trivial instances for types from <code>GHC.Generics</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Eval</span> f <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">    evalAlgebra ::</span> f <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    default<span class="ot"> evalAlgebra ::</span> (<span class="dt">Generic1</span> f, <span class="dt">Eval</span> (<span class="dt">Rep1</span> f)) <span class="ot">=&gt;</span> f <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    evalAlgebra <span class="ot">=</span> evalAlgebra <span class="op">.</span> from1</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">deriving</span> <span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">Eval</span> f <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">M1</span> i c f)</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">deriving</span> <span class="kw">newtype</span> <span class="kw">instance</span> <span class="dt">Eval</span> f <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">Rec1</span> f)</span></code></pre></div>
<p>This gives us a few benefits:</p>
<ul>
<li>No performance penalty when we have many constructors</li>
<li>Chains of <code>L1</code> and <code>R1</code> are replaced with a single constructor with a suitable name, so <code>Show</code> is slightly more sensible and we can write a term by hand without checking for the order of the constructors</li>
</ul>
<h2 id="the-bad">The Bad</h2>
<p>While Data Types a la Carte allows us to re-use individual components such as <code>Val</code> and <code>Add</code> in expression types, those are limited to be simple recursive types.</p>
<p><img src="/images/haskell-ast.svg" alt="Haskell&#39;s AST" /></p>
<p>In practice, programming language ASTs tend to consist of multiple mutually-recursive types, and Data Types a la Carte's approach can't help us express those. I'll expand <a href="https://github.com/lamdu/hypertypes">on how to extend its approach for more complicated ASTs</a> in a future post.</p>
<p>Discussion:</p>
<ul>
<li><img src="/images/reddit.svg" alt="reddit" style="width: 20px; display: inline;"/> <a href="https://www.reddit.com/r/haskell/comments/dcpi4n/nicer_data_types_a_la_carte_with_defaultsignatures/">r/haskell</a></li>
</ul>]]></content>
  </entry>
  <entry>
      <title>How git-mediate made me stop fearing merge conflicts!</title>
      <link href="https://yairchu.github.io/posts/git-mediate-stops-fear"/>
      <id>https://yairchu.github.io/posts/git-mediate-stops-fear</id>
      <updated>2016-12-28T00:00:SZ</updated>
      <category term="code"/>
      <category term="git"/>
      <category term="merge"/>
      <summary>Quick intro to git-mediate</summary>
      <content type="html"><![CDATA[<p>If you’ve ever had to deal with git merge conflicts, then there’s a good chance that these messages give you the chills:</p>
<pre><code>Auto-merging &lt;SOURCE-FILE-PATH&gt;
CONFLICT (content): Merge conflict in &lt;SOURCE-FILE-PATH&gt;
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
<p>They arise when performing merges, reverts, and cherry-picks, and they scare people away and make them reconsider their actions.</p>
<p><img src="/images/kdiff3.png" alt="git mergetool --tool=kdiff3" /></p>
<p>Solving these conflicts <a href="http://stackoverflow.com/questions/161813/how-to-resolve-merge-conflicts-in-git">was hard</a>, time consuming and very error-prone, using either fancy 3-way GUI merge tools or doing it manually (did I mention error prone?).</p>
<p><img src="/images/mine-sweeper-losing.jpeg" alt="When resolving conflicts we have to be careful, do it correctly, and avoid introducing bugs" /></p>
<p>Then I learned about <a href="https://github.com/Peaker/git-mediate">git-mediate</a>, a small open-source tool by Eyal Lotem, which helps resolve merge conflicts rather easily, and most important, <strong>correctly</strong>!</p>
<p>How does it work?</p>
<p>First, configure git to use its “diff3” merge conflict style:</p>
<pre><code>git config --global merge.conflictstyle diff3</code></pre>
<p>Now when conflicts appear, they look like this in the affected files:</p>
<p><img src="/images/diff3-style.jpeg" alt="An unresolved git merge conflict" /></p>
<p>When a conflict occurs, look at it and try to figure out what changed between the base and either the upper or lower branch — choose whichever looks like a simpler change. Now apply this change on the two other parts that don’t yet have it: both the base and the other branch. After your edits, the conflict <em>should</em> look like this:</p>
<p><img src="/images/diff3-resolved.jpeg" alt="Mouth added to both HEAD and base chunks" /></p>
<p>Now we run git-mediate which rewrites the file with one where the conflict is resolved and <code>git add</code>s it if no conflicts remain.</p>
<p>How does it work? It notices that for this conflict one of the branches matches the base, and replaces the conflict with the <em>other</em> branch, which now contains <strong>both changes</strong>.</p>
<p>If git-mediate finds that, after our changes, neither branch is identical to the base, it means that we missed parts of the change. That often happens and it’s ok. We just have to see what we missed, which is easier now that the branch is more similar to the new base, and apply that on the other two parts. We can then run git-mediate again and have our conflicts resolved.</p>
<p>Had we tried to resolve the conflict manually (without git-mediate) we could have easily missed whether we didn’t apply the full change, and in doing so accidentally revert changes in our conflict resolution. By using git-mediate to verify our work and resolve the conflict for us, we avoid such mistakes.</p>
<p>Using git-mediate is a bit like magic, you do a small little change, press the button, and your conflict is resolved!</p>
<p>A few extra tips:</p>
<ul>
<li>Regardless of your merging solution, large merges can often be split into several smaller ones, for example by rebasing feature-branches instead of doing one big merge.</li>
<li>When figuring out the changes in a conflict isn’t simple, <code>git-mediate -d</code> shows, in diff form, the two different changes from the base.</li>
</ul>
<p>Happy merging!</p>
<p>Discussion:</p>
<ul>
<li><img src="/images/Medium_logo_Monogram.svg" alt="medium" style="width: 20px; display: inline;"/> This post was originally <a href="https://medium.com/@yairchu/how-git-mediate-made-me-stop-fearing-merge-conflicts-and-start-treating-them-like-an-easy-game-of-a2c71b919984">posted on Medium</a>. It was migrated to my new blog at 2020.04.21</li>
<li><img src="/images/reddit.svg" alt="reddit" style="width: 20px; display: inline;"/> <a href="https://www.reddit.com/r/git/comments/5kwrnm/how_gitmediate_made_me_stop_fearing_merge/">r/git</a></li>
</ul>]]></content>
  </entry>
</feed>
