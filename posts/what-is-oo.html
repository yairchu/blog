<!DOCTYPE html>
<html lang="en">
<head profile="http://www.w3.org/2005/10/profile">
  <meta charset="UTF-8">
  <meta name="description" content="Yair&#39;s website">
  <meta name="author" content="Yair Chuchem">
  <meta name=viewport content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@yairchu">
<meta name="twitter:creator" content="@yairchu">
<meta name="twitter:title" content="What is Object Oriented Programming">
  <meta name="twitter:description" content="What is OOP">
    <title>What is Object Oriented Programming</title>
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <meta property="og:title" content="What is Object Oriented Programming" />
  <meta property="og:image" content="https://yairchu.github.io/images/" />
</head>
<body>
  <header>
      <nav>
          <a id="beacon" href="/">
              <div id="home-text"> HOME </div>
          </a>
      </nav>
  
      <div class="right-sidebar">
          <a class="ext-link" href="https://github.com/yairchu">
            <img src="/images/github-logo.png" alt="Github Profile"/>
        </a>

          <a class="ext-link" href="https://twitter.com/yairchu">
            <img src="/images/twitter-logo.png" alt="Twitter Profile"/>
        </a>
    <div id="theme-button">DAY</div>
      </div>
  </header>

<div id="page">
  <div class="wrapper">
    <div class="masthead">
      <span class="title">
        What is Object Oriented Programming
      </span>

      <span class="byline">by Yair Chuchem</span>
      <span class="date">2020.10.27</span>
      <div class="metadata">
      </div>
      <div class="tags">
        <a href="/tag/code" class="tag">code</a>
        <a href="/tag/c" class="tag">c</a>
        <a href="/tag/c++" class="tag">c++</a>
        <a href="/tag/oop" class="tag">oop</a>
      </div>
    </div>
  </div>
  <article class="post">
    <p>Wikipedia's <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">definition of OOP</a> is as follows:</p>
<blockquote>
<p><strong>Object-oriented programming (OOP)</strong> is a programming paradigm based on the concept of "objects" ... programs are designed by making them out of objects ... typically in combination with imperative, procedural programming ... multi-paradigm ... <strong>TL;DR</strong></p>
</blockquote>
<p>It's a vague and long definition, which as a programmer I'm less attracted to. I prefer descriptions that are useful and succinct.</p>
<p>In this post I'll give a short description of OOP, and demonstrate it by comparing C and C++. Here it is:</p>
<h2 id="oop">OOP</h2>
<p><em>Object-oriented programming</em> extended procedural programming with <em>namespacing</em> (especially for <em>methods</em>) and <em>encapsulation</em>. These features are widespread today, but they were popularized by the OOP movement.</p>
<p>Some additional concepts used to be considered integral to this style, but their importance has dwindled. Notable among them is <em>inheritence</em>, which many old texts considered to be the main concept of OOP. Today, <em>the only distinguishing feature of OOP is method namespacing</em>.</p>
<h2 id="namespacing">Namespacing</h2>
<p>Method namespacing allows us to give the same name to different <em>methods</em> (aka <em>functions</em>).</p>
<p>Consider the following C code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a>button_add_listener (submit, this);</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">/* ^ Note how we manually prefix our function names with type names */</span></span></code></pre></div>
<p>It reads much nicer in C++:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a>submit.addListener (<span class="kw">this</span>);</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">// ^ Calls the Button::addListener method</span></span></code></pre></div>
<p>Another common OO form of namespacing is <em>overloading</em>, where the compiler infers which function of the same name to call according to which one best fits the types.</p>
<hr />
<p>Nowadays, there are additional namespacing mechanisms which are universally adopted in all modern programming languages, also in non-object-oriented ones:</p>
<p>Explicit namespaces (<code>namespace</code> in C++) provide a general mechanism to disambiguate names. The following Python snippet demonstrates them in the form of module imports:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="im">import</span> numpy <span class="co"># Qualified import</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="im">from</span> numpy <span class="im">import</span> arange <span class="co"># Unqualified import, like &quot;using&quot; in C++.</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>x <span class="op">=</span> numpy.sin(arange(<span class="dv">15</span>))</span></code></pre></div>
<p>An additional form of namespacing is <em>interfaces</em>, or the more general <a href="https://en.wikipedia.org/wiki/Type_class"><em>typeclasses</em></a>. These are not mainly a namespacing feature, but they do allow a form of name reuse in that an interface method call may invoke different methods for different types.</p>
<p>Given the overlapping benefits between the various forms of namespacing, some modern PLs choose not to include the OO concepts of <em>methods</em> and <em>overloading</em>, and in practice those remains the only distinguishers for whether a language is object-oriented or not.</p>
<h2 id="encapsulation">Encapsulation</h2>
<p>Encapsulation lets us limit member variable access to class methods (ie <code>private</code> in C++). It provides several benefits -</p>
<h3 id="stable-apis">Stable APIs</h3>
<p>Users use explicitly defined clean APIs, rather than willy-nilly accessing internals that may be prone to change. This is great!</p>
<h3 id="enforcing-invariants">Enforcing invariants</h3>
<p>Accessing the structure indirectly via class methods allows class implementors to easily impose invariants on the class state.</p>
<p><em>Or at least this used to be the case until the rise of concurrency</em> (aka multi-threading). Nowadays maintaining invariants with mutable state became a challenge involving <code>std::mutex</code>es, <code>std::atomic</code>es, and migraines.</p>
<h3 id="non-oo-styles-of-encapsulation">Non-OO styles of encapsulation</h3>
<p>Procedural languages like C already had some forms of encapsulation with unexposed symbols (ie <code>static</code>) and opaque types.</p>
<p>Modern languages support modules with explicit export lists, which provide the same benefits with a more general interface.</p>
<h2 id="appendix-whatabouts">Appendix: Whatabouts</h2>
<p>According to Wikipedia there is more to OOP than the two concepts that I mentioned above.</p>
<p>In this section I will attempt to refute this claim.</p>
<h3 id="dynamic-dispatch">Dynamic dispatch</h3>
<p>Dynamic dispatch is not uniquely an OO feature. Procedural languages already supported dynamic dispatch via function pointers. Granted, OO did popularize it for a while, but in practice many of the use cases of dynamic dispatch can often be replaced nicely with other mechanisms available in modern PLs such as anonymous functions.</p>
<p>The following OOP style code -</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a>MyWidget::MyWidget()</span>
<span id="cb4-2"><a href="#cb4-2"></a>{</span>
<span id="cb4-3"><a href="#cb4-3"></a>    ...</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="va">m_submit</span>.addListener (<span class="kw">this</span>);</span>
<span id="cb4-5"><a href="#cb4-5"></a>    ...</span>
<span id="cb4-6"><a href="#cb4-6"></a>}</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="dt">void</span> MyWidget::onClick (Button* button)</span>
<span id="cb4-9"><a href="#cb4-9"></a>{</span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="cf">if</span> (button == <span class="va">m_submit</span>) { ... }</span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="cf">else</span> ...</span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">else</span> abort (<span class="st">&quot;Unexpected button!&quot;</span>);</span>
<span id="cb4-13"><a href="#cb4-13"></a>}</span></code></pre></div>
<p>Is nicer in "modern style":</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c++"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>MyWidget::MyWidget()</span>
<span id="cb5-2"><a href="#cb5-2"></a>{</span>
<span id="cb5-3"><a href="#cb5-3"></a>    ...</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="va">m_submit</span>.onClick = [=]{ ... };</span>
<span id="cb5-5"><a href="#cb5-5"></a>    ...</span>
<span id="cb5-6"><a href="#cb5-6"></a>}</span></code></pre></div>
<h3 id="design-patterns">Design patterns</h3>
<p>OOP design patterns are disappearing and being replaced with trivial code using new features, as demonstrated above with the listener pattern is being replaced by using function values. Likewise the visitor pattern was often used to emulate sum-types, and is getting replaced by built-in PL sum-types support.</p>
<h3 id="inheritence">Inheritence</h3>
<p>Inheritence is a famous OOP concept which isn't commonly used in practice. As an example, Google's C++ style guide <a href="https://google.github.io/styleguide/cppguide.html#Inheritance">recommends against using it</a>. Given that modern OOP style avoids it, it doesn't belong in a modern description of OOP style.</p>

    <br>
    <br>

    <!--Share buttons-->
    <div class="social-buttons">
      <a href="https://twitter.com/share" class="twitter-share-button" data-text="Check out: What is Object Oriented Programming - " data-via="yairchu">Tweet</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
      <a href="https://twitter.com/yairchu" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @yairchu</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
      <div class="fb-like" data-href="" data-layout="button" data-action="like" data-show-faces="true" data-share="true"></div>
    </div>
</article>

</div>

<footer>
    Web site built with Haskell using <a href="https://github.com/ChrisPenner/slick">slick</a> ❤️
</footer>

<link href='https://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
<script src="/js/main.js"></script>
</body>
</html>
