<!DOCTYPE html>
<html lang="en"> 
<head profile="http://www.w3.org/2005/10/profile">
    <meta charset="UTF-8">
    <meta name="description" content="Yair&#39;s website">
    <meta name="author" content="Yair Chuchem">
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@yairchu">
<meta name="twitter:creator" content="@yairchu">
<meta name="twitter:title" content="Simplifying Data Types a la Carte using DefaultSignatures">
    <meta name="twitter:description" content="My first blog post using slick">
    <meta name="twitter:image" content="https://yairchu.github.io/images/code.jpg">
    <title>Simplifying Data Types a la Carte using DefaultSignatures</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
</head>
<body>
    <header>
        <nav>
            <a id="beacon" href="/">
                <div id="home-text"> HOME </div>
            </a>
        </nav>
    
        <div class="right-sidebar">
            <a class="ext-link" href="https://github.com/yairchu">
            <img src="/images/github-logo.png" alt="Github Profile"/>
        </a>

            <a class="ext-link" href="https://twitter.com/yairchu">
            <img src="/images/twitter-logo.png" alt="Twitter Profile"/>
        </a>
    <div id="theme-button">DAY</div>
        </div>
    </header>

<div id="page">
    <div class="wrapper">
        <div class="masthead">
            <span class="title">
                Simplifying Data Types a la Carte using DefaultSignatures
            </span>
            <br>

            <img class="post-image" src="/images/code.jpg">
            <br>
            <span class="byline">by Yair Chuchem</span>
            <br>
            <span class="date">Oct 2, 2019</span>
            <br>
            <div class="metadata">
            </div>
        </div>
    </div>
    <article class="post">
        <p><a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf"><em>Data Types a la Carte</em></a> (Swierstra, 2008) showed how to construct the following data structure:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>From simple and re-usable individual components:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">newtype</span> <span class="dt">Val</span> e <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">data</span>    <span class="dt">Add</span> e <span class="ot">=</span> <span class="dt">Add</span> e e <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">type</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Val</span> <span class="op">:+:</span> <span class="dt">Add</span>)</span></code></pre></div>
<p>(<a href="http://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html#t:Fix"><code>Fix</code></a> is available in the <a href="http://hackage.haskell.org/package/recursion-schemes"><code>recursion-schemes</code></a> package and <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#t::-43-:"><code>:+:</code></a> is available from <code>GHC.Generics</code>)</p>
<h2 id="the-good">The Good</h2>
<p>This construction allows to write clean and re-usable modular code. For example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">⇒</span> <span class="dt">Eval</span> f <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">    evalAlgebra ::</span> f <span class="dt">Int</span> <span class="ot">→</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">instance</span> (<span class="dt">Eval</span> f, <span class="dt">Eval</span> g) <span class="ot">⇒</span> <span class="dt">Eval</span> (f <span class="op">:+:</span> g) <span class="kw">where</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    evalAlgebra (<span class="dt">L1</span> x) <span class="ot">=</span> evalAlgebra x</span>
<span id="cb3-6"><a href="#cb3-6"></a>    evalAlgebra (<span class="dt">R1</span> y) <span class="ot">=</span> evalAlgebra y</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Val</span> <span class="kw">where</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    evalAlgebra (<span class="dt">Val</span> x) <span class="ot">=</span> x</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Add</span> <span class="kw">where</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    evalAlgebra (<span class="dt">Add</span> x y) <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>The <code>Eval</code> implementation of <code>Add</code> is usable not just in the <code>Expr</code> type defined above, but also in any other expression language, such as:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">type</span> <span class="dt">Expr2</span> <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Val</span> <span class="op">:+:</span> <span class="dt">Add</span> <span class="op">:+:</span> <span class="dt">Mul</span>)</span></code></pre></div>
<h2 id="the-ugly">The Ugly</h2>
<p>How would we represent an expression, such as <code>1 + 2</code> in the type defined above?</p>
<p>The simple way to do it is <code>Fix (R1 (Fix (L1 (Val 1)) `Add` Fix (L1 (Val 2))))</code>.</p>
<p>The usages of <code>Fix</code>, <code>R1</code> and <code>L1</code> are cumbersome, so to make things easier Swiestra showed how to write the expression as <code>val 1 `add` val 2</code> using an additional type-class and lifting functions per constructor. This makes writing terms convinient, but a few problems remain unsolved:</p>
<ul>
<li>For expression types with a many possible constructors, we pay a performance penalty for this representation, when compared to a single "flat expression algebra"</li>
<li><code>Expr</code>'s <code>Show</code> is still very cumbersome</li>
</ul>
<h3 id="bringing-the-benefits-of-data-types-a-la-carte-to-a-flat-representation">Bringing the benefits of Data Types a la Carte to a flat representation</h3>
<p>Another way to construct <code>Expr</code> is:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="ot">=</span> <span class="dt">EVal</span> (<span class="dt">Val</span> a) <span class="op">|</span> <span class="dt">EAdd</span> (<span class="dt">Add</span> a)</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="kw">deriving</span> (<span class="dt">Generic1</span>, <span class="dt">Functor</span>, <span class="dt">Eval</span>)</span></code></pre></div>
<p>Of note here is the derivation of <code>Eval</code>, which is enabled by using <code>DeriveAnyClass</code> and adding a default implementation in the <code>Eval</code> class along with two trivial instances for types from <code>GHC.Generics</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">⇒</span> <span class="dt">Eval</span> f <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">    evalAlgebra ::</span> f <span class="dt">Int</span> <span class="ot">→</span> <span class="dt">Int</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    default<span class="ot"> evalAlgebra ::</span> (<span class="dt">Generic1</span> f, <span class="dt">Eval</span> (<span class="dt">Rep1</span> f)) <span class="ot">⇒</span> f <span class="dt">Int</span> <span class="ot">→</span> <span class="dt">Int</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    evalAlgebra <span class="ot">=</span> evalAlgebra <span class="op">.</span> from1</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">instance</span> <span class="dt">Eval</span> f <span class="ot">⇒</span> <span class="dt">Eval</span> (<span class="dt">M1</span> i c f) <span class="kw">where</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    evalAlgebra (<span class="dt">M1</span> x) <span class="ot">=</span> evalAlgebra x</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">instance</span> <span class="dt">Eval</span> f <span class="ot">⇒</span> <span class="dt">Eval</span> (<span class="dt">Rec1</span> f) <span class="kw">where</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    evalAlgebra (<span class="dt">Rec1</span> x) <span class="ot">=</span> evalAlgebra x</span></code></pre></div>
<p>Now we can write <code>1 + 2</code> as <code>Fix (EAdd (Fix (EVal (Val 1)) `Add` Fix (EVal (Val 2))))</code>, which is about as cumbersome as the previous verbose method, but it has several advantages:</p>
<ul>
<li>No performance penalty when we have many constructors</li>
<li>Chains of <code>L1</code> and <code>R1</code> are replaced with a single constructor with a suitable name, so <code>Show</code> is slightly more sensible and we can write a term by hand without looking for the order of the constructors in the type.</li>
</ul>
<p>Note that this method is compatible with Swiestra's classes and combinators and so we could still write the expression as <code>val 1 `add` val2</code>!</p>

        <br>
        <br>

        <!--Share buttons-->
        <div class="social-buttons">
            <a href="https://twitter.com/share" class="twitter-share-button"
                                                data-url="https://yairchu.github.io" data-text="Check out: Simplifying Data Types a la Carte using DefaultSignatures - " data-via="yairchu">Tweet</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
            <a href="https://twitter.com/yairchu" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @yairchu</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
            <div class="fb-like" data-href="" data-layout="button" data-action="like" data-show-faces="true" data-share="true"></div>
        </div>
</article>

</div>

<footer>
    Built with Haskell using <a href="https://github.com/ChrisPenner/slick">slick</a> ❤️
</footer>

<link href='https://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Oswald' rel='stylesheet' type='text/css'>
<script src="/js/main.js"></script>
</body>
</html>
